import 'package:flutter_tts/flutter_tts.dart';
import 'package:shared_preferences/shared_preferences.dart';

enum TtsVoicePreset { system, australianFemale, australianMale }

class TtsController {
  TtsController._();
  static final TtsController instance = TtsController._();

  final FlutterTts _tts = FlutterTts();

  double rate = 0.6;
  double pitch = 1.0;
  TtsVoicePreset preset = TtsVoicePreset.system;

  // Settings keys
  static const _kRate   = 'tts_rate';
  static const _kPitch  = 'tts_pitch';
  static const _kPreset = 'tts_preset';

  // Persist the exact voice
  static const _kEngineKey     = 'tts_engine';
  static const _kVoiceNameKey  = 'tts_voice_name';
  static const _kVoiceLocaleKey= 'tts_voice_locale';

  Future<void> init() async {
    final prefs = await SharedPreferences.getInstance();
    rate   = prefs.getDouble(_kRate) ?? 0.6;
    pitch  = prefs.getDouble(_kPitch) ?? 1.0;
    final presetStr = prefs.getString(_kPreset) ?? TtsVoicePreset.system.name;
    preset = TtsVoicePreset.values.firstWhere(
      (e) => e.name == presetStr,
      orElse: () => TtsVoicePreset.system,
    );

    await _tts.setSharedInstance(true);
    await _tts.setSpeechRate(rate);
    await _tts.setPitch(pitch);

    // Always re-apply a concrete voice (prefers en-AU)
    await _applySavedVoiceOrAUDefault();

    // If user chose a preset, enforce it too
    if (preset != TtsVoicePreset.system) {
      await _selectVoiceForPreset(preset);
    }
  }

  Future<void> speak(String text) async {
    await _tts.stop();
    await _tts.setSpeechRate(rate);
    await _tts.setPitch(pitch);
    if (preset != TtsVoicePreset.system) {
      await _selectVoiceForPreset(preset);
    }
    await _tts.speak(text);
  }

  Future<void> stop() => _tts.stop();

  Future<void> setRate(double newRate) async {
    rate = newRate.clamp(0.1, 1.0);
    await _tts.setSpeechRate(rate);
    final prefs = await SharedPreferences.getInstance();
    await prefs.setDouble(_kRate, rate);
  }

  Future<void> setPitch(double newPitch) async {
    pitch = newPitch.clamp(0.5, 2.0);
    await _tts.setPitch(pitch);
    final prefs = await SharedPreferences.getInstance();
    await prefs.setDouble(_kPitch, pitch);
  }

  Future<void> setPreset(TtsVoicePreset p) async {
    preset = p;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_kPreset, p.name);
    if (p != TtsVoicePreset.system) {
      await _selectVoiceForPreset(p);
    }
  }

  // Allow UI to persist an explicit user-picked voice
  Future<void> setVoiceChoice({String? engine, required String name, required String locale}) async {
    final prefs = await SharedPreferences.getInstance();
    if (engine != null && engine.isNotEmpty) {
      try { await _tts.setEngine(engine); } catch (_) {}
      await prefs.setString(_kEngineKey, engine);
    }
    try { await _tts.setLanguage(locale); } catch (_) {}
    try { await _tts.setVoice({'name': name, 'locale': locale}); } catch (_) {}
    await prefs.setString(_kVoiceNameKey, name);
    await prefs.setString(_kVoiceLocaleKey, locale);
  }

  Future<void> _selectVoiceForPreset(TtsVoicePreset p) async {
    List<dynamic>? raw;
    try { raw = await _tts.getVoices; } catch (_) { raw = const []; }

    final voices = <Map<String,String>>[];
    for (final v in raw ?? const []) {
      if (v is Map) {
        voices.add({
          'name':   (v['name'] ?? '').toString(),
          'locale': (v['locale'] ?? '').toString(),
        });
      }
    }

    Map<String,String>? chosen;
    final enAu = voices.where((m) => (m['locale'] ?? '').startsWith('en-AU'));

    bool hasMaleTag(Map<String,String> m)  => (m['name'] ?? '').toLowerCase().contains('male');
    bool hasFemTag(Map<String,String> m)   => (m['name'] ?? '').toLowerCase().contains('female') || (m['name'] ?? '').toLowerCase().contains('fema');

    if (p == TtsVoicePreset.australianFemale) {
      chosen = enAu.firstWhere(hasFemTag, orElse: () => (enAu.isNotEmpty ? enAu.first : (voices.isNotEmpty ? voices.first : {})));
    } else if (p == TtsVoicePreset.australianMale) {
      chosen = enAu.firstWhere(hasMaleTag, orElse: () => (enAu.isNotEmpty ? enAu.first : (voices.isNotEmpty ? voices.first : {})));
    } else {
      return;
    }

    if (chosen != null && chosen.isNotEmpty) {
      final loc = chosen['locale'] ?? 'en-AU';
      try { await _tts.setLanguage(loc); } catch (_) {}
      try { await _tts.setVoice({'name': chosen['name'] ?? '', 'locale': loc}); } catch (_) {}
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_kVoiceNameKey, chosen['name'] ?? '');
      await prefs.setString(_kVoiceLocaleKey, loc);
    }
  }

  Future<void> _applySavedVoiceOrAUDefault() async {
    final prefs = await SharedPreferences.getInstance();
    final savedEngine = prefs.getString(_kEngineKey);
    final savedName   = prefs.getString(_kVoiceNameKey);
    final savedLocale = prefs.getString(_kVoiceLocaleKey);

    // Prefer Google engine on Android for stable AU voices
    try {
      await _tts.setEngine(
        (savedEngine != null && savedEngine.isNotEmpty)
          ? savedEngine
          : 'com.google.android.tts'
      );
    } catch (_) {}

    List<dynamic>? raw;
    try { raw = await _tts.getVoices; } catch (_) { raw = const []; }

    final voices = <Map<String,String>>[];
    for (final v in raw ?? const []) {
      if (v is Map) {
        voices.add({
          'name':   (v['name'] ?? '').toString(),
          'locale': (v['locale'] ?? '').toString(),
        });
      }
    }

    Map<String,String>? chosen;

    // 1) Exact saved voice
    if (savedName != null && savedLocale != null) {
      for (final v in voices) {
        if (v['name'] == savedName && v['locale'] == savedLocale) { chosen = v; break; }
      }
    }

    // 2) Any en-AU
    chosen ??= voices.firstWhere(
      (v) => (v['locale'] ?? '').startsWith('en-AU'),
      orElse: () => {},
    );

    // 3) Any English
    if ((chosen ?? {}).isEmpty) {
      chosen = voices.firstWhere(
        (v) => (v['locale'] ?? '').startsWith('en-'),
        orElse: () => {},
      );
    }

    if ((chosen ?? {}).isNotEmpty) {
      final loc = chosen!['locale'] ?? 'en-AU';
      try { await _tts.setLanguage(loc); } catch (_) {}
      try { await _tts.setVoice({'name': chosen['name'] ?? '', 'locale': loc}); } catch (_) {}
      await prefs.setString(_kVoiceNameKey, chosen['name'] ?? '');
      await prefs.setString(_kVoiceLocaleKey, loc);
    } else {
      // Fallback: language only
      try { await _tts.setLanguage(savedLocale ?? 'en-AU'); } catch (_) {}
    }
  }
}